## Intro

- Container vs Presentation Components
- React-Redux
    - Provider
    - Connect
- A Chat with Redux


## Container vs Presentational Components

### Two Component Types

- presentational components are not tie to an specific behavior, it sbehavior is passed down from a container component via props 
- Container componente sis just a React coponent that uses store.subscribe to read part of the Redux state tree and supply props to child components

|**Container**|**Presentational**|
|--|--|
|Focus on how things work|Focus on how things look|
|Aware of Redux|Unawere of Redux (recive data and actions via props)|
|Subscribe to Redux State|Read data from props|
|Dispatch Redux Actions|Invoke callbacks on props (fire up actions by the callbascks passed down via props)|
|Generated by react-redux|Written by hand|

## React-redux introduction

- react-redux handles {store ->r react} in the flow
- react-redux ties your react components together with redux

|**Provider component**|**Connect component**|
|--|--|
| Attaches app to store| Creates container components|

### Provides component

- Attaches app to store
- is utilized at your aplication's root.
- wraps the entire application
- attaches the application to the redux store
- theorically you dont need to use the provider component 
- so provider make the store available to all your components automatically
- You only need to used once when you render your root the component 
```js
<Provider store={this.props.store}>
    <App/>
</Provider>
```
> `React's context: Useful for library authors. Dangerous for you.`

### Connect

- Creates container components
- wrap our component so its connected to the redux store
- connects your react component to the store so the functions is certainly named well 

```js
function mapStateToProps(state, ownProps){
    return {appState: state.authosReducer };
}
// pass connect two functions


export default connect(
    mapStateToProps, // specifies the state you want to expose to your component
    mapDispatchToProps // specifies the actions you want to expose
)(AuthorPage);
```
- in redux nearly all your components can be stateless functional componets if you'd like 

Benefits:
- No manual unsuscribe
- No lifecycle methods required
- Declare what subset of state you want 
- Enhanced performance for free ( your component only renders when the specific data you've connected changes)

## mapStateToProps

- useful for defining what part of Redux store you want to expose on your component
- when you define this function, the component will subscribe to redux store updates
- Any time it updates, mapStateToProps will be called 
- returns an object
- each property on the object you define will become a property on your container component 
- Determinates what state is available on your container component
- Logical place to filter or, otherwise, transform your state so its most conveniently shaped and sorted for you components use.

```js
// in a simple app you may have one reducer and one container component
// when grow up you may like to create diferent components to manage different pages or sectios of your app
// different reducers to different sections of the store
function mapStateToProps(state){
    return {
        appState: state
    };
}
```

- makes all of your state accessble to the component via props.
- `this.props.appstate`: within the component to acces any state that is handled by my appstate reducer.
- expose part of my store's state to the component via props like this:
    ```js
        appState: state
    ```
    - each object will become a prop on my component

- every time the component is updated, the mapStateToProps function is called

### Reselect

- `Memoize for perfomance`: about keeping track of the result of each function call so that the function does not have to run angain if tis already been run with the same parameters
    - to avoid heavy functions every time mapStateToProps is called 
    - like caching for function calls 
    - reselect just check whether it's already been called with specified parameter, and if it has, it doenst call the  function. instead, it just returns the memoized valued instead.


## mapDispatchToProps

- Let us specify what actions we want to expose as props
- Determines what actions we want to expose to our component instead of what state
- Receives disparch as its lone parameter
- Returns the callback props that you want to pass down 
```js
function mapDispatchToProps(dispatch){
    return {
        actions: bindActionCreators(actions,dispatch)
    };
}
```


### 3 Ways to Handle mapDispatchToProps

- Expose your actions to your components

#### Ignore it. Use dispatch

- `this.props.dispatch(loadCourses());`
- when omit it, then the dispatch function will be attached to your container component.
    - this mean you can call dispatch manually and pass it an action creator.

##### Example

- adds a dispatch prop to your component
```js
// In component...
//use this dispatch prop to call your action creator 
this.props.dispatch(loadCourses())
```
Two downsides
- Boiler plate: takes more code to dispatch an action 
- 
#### Manually wrap

- in dispatch calls within the mapDispatchToProps function
- wrapping the creator in a function that calls dispatch
- kepps the calls in my actual component shorter at the cost of some extra coding here in mapDispatchToProps
```js
function mapDispatchToProps(dispatch){
    return {
        loadCourses: () => {
            dispatch(loadCourses());
        }
    }
}
```

#### Use bindActionCreators

- convenience function that wraps your action creator in dispatch calls for you

```js
function mapDispatchToProps(dispatch){
    return {
        actions:
            bindActionCreators(actions, dispatch)
    };
}
```

- does what we do in option 2 automatically
